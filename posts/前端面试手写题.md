---
title: ’前端面试手写题'
date: '2022-09-01'
---

## 前端面试手写题


```
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <style>
      #app {
        width: 200px;
        height: 200px;
        background-color: black;
        position: absolute;
        top: -9999px;
        left: -9999px;
      }
    </style>
    <style>
      .father {
        display: table-cell;
        width: 200px;
        height: 200px;
        background: skyblue;
        vertical-align: middle;
        text-align: center;
      }

      .son {
        display: inline-block;
        width: 100px;
        height: 100px;
        background: red;
      }
    </style>
    <link rel="preload" href="./src/assets/imgs/garden.jpg" as="image" />

    <style>
      .colorful {
        height: 100px;
        width: 300px;
        background: repeating-linear-gradient(90deg, yellow 22.5%, black);
      }
    </style>

    <script></script>
  </head>

  <body>
    <style>
      .flex {
        display: flex;
        width: 200px;
        height: 100px;
        border: 1px solid black;
      }
      .left {
        flex: 3 2 50px;
        background: red;
      }
      .right {
        flex: 2 1 200px;
        background: blue;
      }
    </style>

    <div class="flex">
      <div class="left"></div>
      <div class="right"></div>
    </div>
    <div class="colorful"></div>
    <style>
      .border {
        width: 100px;
        height: 100px;
        border: 0.5px solid gray;
        background-color: black;
      }
      .border2 {
        width: 100px;
        height: 100px;
        background-color: yellow;
        box-shadow: 0 -1px 1px -1px black, 1px 0 1px -1px #e5e5e5,
          0 1px 1px -1px #e5e5e5, -1px 0 1px -1px #e5e5e5;
        border: 0.5px solid #e5e5e5;
      }
      .border3 {
        position: relative;
        width: 100px;
        height: 100px;
        background-color: yellow;
        margin-top: 10px;
      }
      .border3::after {
        position: absolute;
        content: "";
        background-color: #e5e5e5;
        width: 100%;
        height: 1px;
        transform: scale(1, 0.5);
        transform-origin: top left;
        top: 0;
        left: 0;
      }
      .border4 {
        position: relative;
        width: 100px;
        height: 100px;
        background-color: yellow;
        margin-top: 10px;
      }
      .border4::after {
        position: absolute;
        content: "";
        border: 1px solid #e5e5e5;
        width: 200%;
        height: 200%;
        box-sizing: border-box;
        transform: scale(0.5);
        transform-origin: top left;
        top: 0;
        left: 0;
      }
    </style>
    <div class="border"></div>
    <div class="border2"></div>
    <div class="border3"></div>
    <div class="border4"></div>
    <!--
    <button id="btn">按钮</button>
    <div id="app"></div>
    <ul class="myList"></ul>
    <img
      id="img"
      src="./src/assets/imgs/music.png"
      data-src="./src/assets/imgs/garden.jpg"
      style="width: 200px; height: 200px"
    />
    <button @click="showImg"></button>
    <div class="father">
      <div class="son"></div>
    </div>
    <p></p>
    -->
    <!--
    <img src="./img/default.jpg" data-src="./img/1.jpg" />
    <img src="./img/default.jpg" data-src="./img/2.jpg" />
    <img src="./img/default.jpg" data-src="./img/3.jpg" />
    <img src="./img/default.jpg" data-src="./img/4.jpg" />
    <img src="./img/default.jpg" data-src="./img/5.jpg" />
    -->
    <script>
      function showImg() {
        const img = document.querySelector("#img");
      }
      // 利用getBoundingClientRect和IntersectionObserver实现图片懒加载
      function Lazyload() {
        let clientHeight =
          window.innerHeight ||
          document.documentElement.clientHeight ||
          document.body.clientHeight;
        let imgs = document.querySelectorAll("img[data-src]");
        imgs.forEach((item, index) => {
          if (item.dataset.src === "") return;
          let rect = item.getBoundingClientRect();
          if (rect.bottom >= 0 && rect.top < clientHeight) {
            item.src = item.dataset.src;
            item.removeAttribute("data-src");
          }
        });
      }

      // 节流，避免频繁地浏览器滚轮移动消耗性能
      function throttle(fn, delay) {
        let timer = null;
        let preTime = Date.now();
        return function (arguments) {
          let nowTime = Date.now();
          let lastTime = delay - (nowTime - preTime);
          clearTimeout(timer);
          if (lastTime <= 0) {
            fn.call(this, arguments);
            preTime = Date.now();
          } else {
            timer = setTimeout(() => {
              fn.call(this, arguments);
              preTime = Date.now();
            }, lastTime);
          }
        };
      }
      const imgs = document.querySelectorAll("img[data-src]");
      //IntersectionObserver 是浏览器原生提供的构造函数，接受两个参数：callback 是可见性变化时的回调函数，option 是配置对象（该参数可选）
      //callback会触发两次，一次是元素进入视口，一次是元素离开视口
      //entries是一个数组，数组中的元素是IntersectionObserverEntry对象
      var observer = new IntersectionObserver((entries, self) => {
        entries.forEach((entry) => {
          if (entry.isIntersecting) {
            let img = entry.target;
            if (img.dataset.src) {
              img.src = img.dataset.src;
              img.removeAttribute("data-src");
            }
            self.unobserve(entry.target);
          }
        });
      });
      imgs.forEach((image) => {
        observer.observe(image);
      });
    </script>
    <script>
      //1.实现一个浅拷贝
      function clone(source) {
        if (typeof source === "object" && source !== null) {
          const cloneTarget = Array.isArray(source) ? [] : {};
          //for in可以遍历对象的所有属性包括继承的
          for (let prop in source) {
            if (source.hasOwnProperty(prop)) {
              cloneTarget[prop] = source[prop];
            }
          }
        } else return source;
      }
      function clone(source) {
        if (typeof source === "object" && !source) {
          const cloneTarget = Array.isArray(source) ? [] : {};
          // for in 可以遍历对象的所有属性包括原型链上的
          for (let prop in source) {
            if (source.hasOwnProperty(prop)) {
              cloneTarget[prop] = source[prop];
            }
          }
        } else return source;
      }
      //2.实现一个深拷贝(递归拷贝target的属性)
      function deepclone(target) {
        if (typeof target !== "object" || !target) return target;
        //注意识别target是数组还是对象
        var newObj = Array.isArray(target) ? [] : {};
        for (let prop in target) {
          if (target.hasOwnProperty(prop))
            newObj[prop] = deepclone(target[prop]);
        }
        return newObj;
      }
      function deepclone(target) {
        if (typeof target !== "object" || !target) return target;
      }
      /*
               var target = { name: { nickname: "mike", value: "tyj" } };
               var newObj = deepclone(target);
               console.log(newObj);
               */
      //循环引用可能会导致无限递归栈溢出
      /*
                 var obj2 = { id: 2 };
                 var obj1 = { target: obj2, id: 1 };
                 obj2.target = obj1;
                 var obj = deepclone(obj1);
                 console.log(obj);
               */

      //3.实现一个深拷贝，考虑函数，正则，循环引用等情况
      var isObject = (source) => {
        return (
          source !== null &&
          (typeof source === "object" || typeof source === "function")
        );
      };
      function deepclone(source, map = new Map()) {
        // 返回已缓存的对象
        if (map.get(source)) return source;
        // 直接返回!isObject的对象
        if (!isObject(source)) return source;
        const constructor = source.constructor;
        // 检测当前对象source是否与正则,日期等对象匹配
        if (/^(RegExp|Date)$/i.test(constructor.name)) {
          // 返回一个新的（正则类/日期类）的对象
          return new constructor(source);
        }
        const cloneTarget = Array.isArray(source) ? [] : {};
        // 缓存对象,给对象作标记
        map.set(source, true);
        for (let prop in source) {
          if (source.hasOwnProperty(prop)) {
            // map为循环引用的对象做标记，防止无限递归
            cloneTarget[prop] = deepclone(source[prop], map);
          }
        }
        return cloneTarget;
      }
      var isObject = (target) =>
        target !== null &&
        (typeof target === "object" || typeof target === "function");

      function deepclone_pro(target, map = new Map()) {
        if (map.get(target)) return target;
        if (!target || typeof target !== "object") return target;
        let constructor = target.constructor;
        // 检测当前对象target是否与 正则、日期格式对象匹配
        if (/^(RegExp|Date)$/i.test(constructor.name)) {
          return new constructor(target); // 创建一个新的特殊对象(正则类/日期类)的实例
        }

        if (isObject(target)) {
          map.set(target, true); // 为循环引用的对象做标记
          let newObj = Array.isArray(target) ? [] : {};
          for (let prop in target) {
            if (target.hasOwnProperty(prop)) {
              newObj[prop] = deepclone_pro(target[prop], map); //map为循环引用的对象做标记，防止无限递归
            }
          }
        }
        return newObj;
      }
      var isObject = (obj) =>
        obj !== null && (typeof obj === "function" || typeof obj === "object");
      function deepclone(obj, map = new Map()) {
        if (!isObject(obj)) return obj;
        if (map.get(obj)) return obj;
        let constructor = obj.constructor;
        if (/^(RegExp|Date)$/i.test(constructor.name)) {
          return new constructor(obj);
        }
        let target = obj instanceof Array ? [] : {};
        map.set(obj, true);
        for (let prop in obj) {
          if (obj.hasOwnProperty(prop)) {
            target[prop] = deepclone(obj[prop], map);
          }
        }
        return target;
      }

      var obj2 = { id: 2 };
      var obj1 = { target: obj2, id: 1 };
      obj2.target = obj1;
      var obj = deepclone(obj1);
      //console.log(obj);

      //4.instanceOf机制
      function instanceOf(obj, target) {
        target = target.prototype;
        obj = obj.__proto__; // 处理兼容性问题，可以使用Object.getPrototypeOf()
        while (true) {
          if (obj === target) return true;
          if (obj === null) return false;
          obj = obj.__proto__;
        }
      }
      /*
               var obj = new Array();
               console.log(instanceOf(obj, Object));
               */
      //另一个版本使用Object.getPrototypeOf()
      function _instanceOf(obj, target) {
        target = target.prototype;
        obj = Object.getPrototypeOf(obj); // 处理兼容性问题，可以使用Object.getPrototypeOf()
        while (true) {
          if (obj === target) return true;
          if (obj === null) return false;
          obj = Object.getPrototypeOf(obj);
        }
      }
      /*
               var obj = new Array();
               console.log(_instanceOf(obj, Object));
               */

      //5.手动实现防抖函数，最后一次触发为准与以第一次触发为准
      //（1）频繁触发只触发一次，以最后一次触发为准
      function debounce(fn, delay) {
        // 闭包，形成私有变量
        let timer = null;
        // arguements是类数组对象
        return function (arguments) {
          // 清除定时器，避免多次触发fn
          clearTimeout(timer);
          timer = setTimeout(() => {
            fn.call(this, arguments);
          }, delay);
        };
      }
      //(2)以第一次触发为准
      function debounce2(fn, delay, immediate) {
        let timer = null;
        return function () {
          // 第一次触发时timer为null
          let now = !timer;
          if (immediate) {
            if (now) {
              // timer为null,立即执行fn函数
              fn.call(this, arguments);
            }
            timer = setTimeout(() => {
              timer = null;
            }, delay);
          } else {
            clearTimeout(timer);
            timer = setTimeout(() => {
              timer = null;
              fn.call(this, arguments);
            }, delay);
          }
        };
      }
      function debounce2(fn, delay, immediate) {
        let timer = null;
        return function (arguments) {
          if (immediate) {
            let now = !timer; //timer为null,说明是第一次触发
            if (now) {
              fn.call(this, arguments);
            }
            timer = setTimeout(() => {
              timer = null;
            }, delay);
          } else {
            clearTimeout(timer);
            timer = setTimeout(() => {
              timer = null;
              fn.call(this, arguments);
            }, delay);
          }
        };
      }
      /*
               var alertSomething = debounce2(() => console.log("bingo"), 5000, true);
                 */

      //6.手动实现节流,n秒内只执行一次
      function throttle(fn, delay) {
        let preTime = Date.now();
        let timer = null;
        return function () {
          let nowTime = Date.now();
          let leftTime = delay - (nowTime - preTime);
          clearTimeout(timer);
          if (leftTime < 0) {
            fn.call(this, arguments);
            preTime = Date.now();
          } else {
            timer = setTimeout(() => {
              preTime = Date.now();
              fn.call(this, arguments);
            }, leftTime);
          }
        };
      }

      function throttle(fn, delay) {
        let preTime = Date.now();
        let timer = null;
        return function (arguments) {
          let nowTime = Date.now();
          let lastTime = delay - (nowTime - preTime);
          clearTimeout(timer);
          if (lastTime <= 0) {
            fn.call(this, arguments);
            preTime = Date.now();
          } else {
            timer = setTimeout(() => {
              fn.call(this, arguments);
              preTime = Date.now();
            }, delay - (nowTime - preTime));
          }
        };
      }
      /*
               var btn = document.querySelector("#btn");
               var handler = throttle(() => console.log("throttle"), 3000);
               btn.addEventListener("click", handler);
               */

      //7.手动实现Object.create
      //若let obj = Object.create(obj2）--->obj.__proto__=obj2
      Object.prototype.create = function (target) {
        if (target !== "object" || !target) throw Error("must be an object");
        let func = function () {};
        func.prototype = target;
        return new func();
      };
      /*
               let obj2 = { name: "tyj" };
               let obj = Object.create(obj2);
               console.log(obj.name);
               */

      var obj = {
        id: 1,
        children: [
          { id: 2, children: [{ id: 3, children: [] }] },
          {
            id: 4,
            children: [
              { id: 5, children: [] },
              { id: 6, children: [] },
            ],
          },
        ],
      };
      var ans = [];
      var res;
      function findNode(obj, val) {
        if (obj.id === val) {
          ans.push(obj.id);
          res = ans.slice();
          return;
        }
        for (let i = 0; i < obj.children.length; i++) {
          ans.push(obj.id);
          findNode(obj.children[i], val);
          ans.pop();
        }
      }
      findNode(obj, 5);
      //console.log(res);
      //8.手动实现new
      //let obj = new Func();-->obj.__proto__ = Func.prototype,也有可能new出来的结果有返回值,比如返回一个对象或是返回一个函数
      function _new(target, ...arguments) {
        let obj = Object.create(target.prototype);
        // obj.__proto__ === target.prototype
        let result = target.call(obj, ...arguments);
        // 需要考虑构造函数的返回值是函数或者对象
        if (result && /^(function|object)$/.test(result)) return result;
        return obj;
      }
      function __new(target, ...args) {
        let obj = Object.create(target.prototype);
        let result = target.call(obj, ...args);
        if (result && /^(function|object)$/i.test(result)) return result;
        return obj;
      }
      // var name = 'tyj';
      // function Cat(name) {
      //   this.name = name;
      //   this.printName = function() {
      //     console.log(this.name);
      //   }
      //   this.printName2 = () => {
      //     console.log(this.name);
      //   }
      //   return 1;
      // }
      // var cat = new Cat('tyj2');
      // cat.printName();
      // cat.printName2();
      // var printName = cat.printName;
      // var printName2 = cat.printName2;
      // printName();
      // printName2();

      //9.手动实现call，apply，bind
      //https://juejin.cn/post/6870319532955828231#heading-12
      //10.实现一个代理，拦截对btn的innerHTML属性的赋值
      /*
               const btn = document.querySelector("#btn");
               let handler = {
                 set(target, key, value, proxy) {
                   if (key === "innerHTML" && typeof value !== "number")
                     throw Error("failed");
                   //反射Reflect类型执行默认的set行为会报错
                   //return Reflect.set(target,key,value)
                   target[key] = value;
                 },
               };
               let proxy = new Proxy(btn, handler);
               proxy.innerHTML = 123456;
               */
      //11.手动实现call，apply，bind
      Function.prototype.Call = function (arguments) {
        var context = Array.prototype.slice.call(arguments, 0)[0];
        // arguements类数组对象
        context = Array.of(arguments)[0];
        // 工厂模式替代上面的Array.prototype.slice.call
        context = context || window;
        var args = Array.prototype.slice.call(arguments, 1);
        context["fn"] = this;
        var res = context["fn"](...args);
        delete context["fn"];
        return res;
      };
      /**
       * context: 要改变的函数中的this指向，写谁就是谁
       * args：传递给函数的实参信息
       * this：要处理的函数 fn
       */
      //12.手动实现apply
      Function.prototype.Apply = function (context, args) {
        context = context || window;
        context.fn = this;
        var res = context.fn(...args);
        delete context.fn;
        return res;
      };
      /*
               var func = function (name, age) {
                 console.log(this);
                 console.log(this.age);
                 console.log(name, age);
               };
               var age = 18;
               var obj = {
                 name: "tyj",
                 age: 180,
               };
               func.Apply(obj, ["好人", 18]);
               func();
               */
      //13.手动实现bind
      Function.prototype.Bind = function (context, ...args) {
        context = context || window;
        var self = this;
        var args1 = Array.of(...args);
        function f1() {}
        function f2() {
          var args2 = Array.prototype.slice.call(arguments);
          return self.apply(
            this instanceof f2 ? this : context,
            args1.concat(args2)
          );
        }
        f1.prototype = self.prototype;
        f2.prototype = new f1();
        return f2;
      };

      Function.prototype.Bind = function (context, ...args) {
        context = context || window;
        var self = this;
        // ...args也是一个参数序列，但是只能用Array.of,不可以用Array.prototype.slice.call;
        var args1 = Array.of(...args);
        console.log(args1);
        function f1() {}
        function f2() {
          // 细节，函数的参数不要填arguments，会和真正的arguments对象冲突，arguments对象是一个参数序列，只能用Array.prototype.slice.call
          var args2 = Array.prototype.slice.call(arguments);
          console.log(args2);
          return self.Apply(
            this instanceof f2 ? this : context,
            args1.concat(args2)
          );
        }
        f1.prototype = self.prototype;
        f2.prototype = new f1();
        return f2;
      };
      /*
               var func = function (name, age) {
                 console.log(this);
                 console.log(this.age);
                 console.log(name, age);
               };
               var obj = {
                 age: 18,
               };
               var obj2 = func.Bind(obj, 123);
               obj2(123);
               */
      //14.实现flat()ES5

      Array.prototype.flat = function () {
        var res = [];
        var self = this;
        function cycle(self) {
          for (let i = 0; i < self.length; i++) {
            if (Array.isArray(self[i])) {
              cycle(self[i]);
            } else {
              res.push(self[i]);
            }
          }
        }
        cycle(self);
        return res;
      };
      /*
                var arr = [1, 2, 3, 4, [2, [5, 1, 6]]];
               console.log(arr.flat());
               */
      //15.三种思路实现数组去重
      //（1）slice+findIndex
      function seperate(arr) {
        for (let i = 0; i < arr.length; i++) {
          const target = arr[i];
          const arr2 = arr.slice(i + 1);
          if (arr2.findIndex((item) => item === target) !== -1) {
            arr[i] = arr[arr.length - 1];
            arr.length--;
            i--;
          }
        }
        return arr;
      }
      //(2)对象存值
      function seperate(arr) {
        let obj = {};
        for (let i = 0; i < arr.length; i++) {
          let item = arr[i]; // 取得当前项
          if (typeof obj[item] !== "undefined") {
            // obj 中存在当前属性，则证明当前项 之前已经是 obj属性了
            // 删除当前项
            arr[i] = arr[arr.length - 1];
            arr.length--;
            i--;
          }
          obj[item] = item; // obj {10: 10, 16: 16, 25: 25 ...}
        }
        obj = null; // 垃圾回收
        console.log(arr); // [ 16, 23, 12, 15, 25 ]
      }
      //(3)正则表达式
      function seperate(arr) {
        arr.sort((a, b) => a - b);
        let str = arr.join("@") + "@";
        let res = [];
        str.replace(/(\d+)(@\1)*/g, (all, item) => {
          res.push(item);
        });
        return res;
      }
      //(4)排序后快慢指针
      function seperate(arr) {
        arr.sort((a, b) => a - b);
        let slow = 0;
        let fast = 0;
        while (fast < arr.length) {
          while (arr[fast] === arr[fast + 1]) fast++;
          arr[slow] = arr[fast];
          slow++;
          fast++;
        }
        return arr.slice(0, slow);
      }
      /*
               console.log(seperate([1, 1, 1, 2, 5, 3, 2, 2, 1, 5]));
               */

      //16.基于Promise实现ajax,也就是基于原生网络请求去实现ajax
      function ajax(url, method) {
        return new Promise((resolve, reject) => {
          const xhr = null;
          if (XMLHttpRequest in window) {
            xhr = new XMLHttpRequest();
          } else {
            xhr = new ActiveXObject("Microsoft.XMLHTTP");
          }
          xhr.open(url, method, true);
          xhr.onreadystatechange = function () {
            if (xhr.readyState === 4) {
              if (xhr.status === 200) resolve(xhr.responseText);
              else if (xhr.status === 404) throw Error("404");
            } else reject("error");
          };
          xhr.send();
        });
      }
      //17.自定义迭代且实现next()方法与return()方法
      //自定义限制迭代的次数
      //暂时无法复现红宝书的内容
      class Counter {
        constructor(limit) {
          this.limit = limit;
        }
        [Symbol.iterator]() {
          let count = 1;
          let limit = this.limit;
          return {
            next() {
              if (count <= limit) {
                return { done: "false", value: count++ };
              } else {
                return { done: "true" };
              }
            },
            return() {
              return { done: "true", value: count };
            },
          };
        }
      }
      /*
               var counter = new Counter(3);
               console.log(counter[Symbol.iterator]());
               let iter = counter[Symbol.iterator]();
               for (let i of iter) {
                 console.log(i);
               }
               */
      //18.多种方式实现继承
      //（1）原型链继承，不同实例会继承相同原型对象，会发生混乱
      function Father() {
        this.name = "tyj";
        this.arr = [1, 2, 3];
      }
      function Child() {
        this.type = "child";
      }
      Child.prototype = new Father();
      var child1 = new Child();
      var child2 = new Child();
      child1.arr.push(4);
      /*
               console.log(child1.arr, child2.arr);
               */
      //(2)构造函数，利用call调用父类构造函数，但不能继承父类的原型
      function Parent() {
        this.name = "parent1";
      }
      Parent.prototype.getName = function () {
        return this.name;
      };
      function Child() {
        Parent.call(this);
        this.type = "child";
      }
      /*
               var child = new Child();
               console.log(child); // 没问题
               console.log(child.getName()); // 会报错
               */
      //(3)组合继承
      function Parent() {
        this.name = "parent1";
      }
      Parent.prototype.getName = function () {
        return this.name;
      };
      function Child() {
        Parent.call(this);
        this.type = "child";
      }
      /*
               Child.prototype = new Parent();
               console.log(Child.prototype.__proto__ === Parent.prototype);
               Child.prototype.constructor = Child;
               var child = new Child();
               */
      /*
               console.log(child.type);
               console.log(child.getName());
               */
      //(4) 原型式继承，会造成类似（1）的错误
      //Object.create是浅拷贝，多个引用类型的变量指向同一片内存

      //var child = Object.create(Parent);
      //以现有的Parent承担child的[[Prototype]]属性

      //Child.prototype = new Parent();
      //console.log(Child.prototype.__proto__ === Parent.prototype);--->true

      let parent4 = {
        name: "parent4",
        friends: ["p1", "p2", "p3"],
        getName: function () {
          return this.name;
        },
      };

      let person4 = Object.create(parent4);
      person4.name = "tom";
      person4.friends.push("jerry");

      let person5 = Object.create(parent4);
      person5.friends.push("lucy");
      /*
               console.log(person4.name); // tom
               console.log(person4.name === person4.getName()); // true
               console.log(person5.name); // parent4
               console.log(person4.friends); // ["p1", "p2", "p3","jerry","lucy"]
               console.log(person5.friends); // ["p1", "p2", "p3","jerry","lucy"]

                 */
      //（5）寄生式继承
      //（6）寄生式组合继承
      function Parent() {
        this.name = "tyj";
        this.arr = [1, 2, 3];
      }
      function Child() {
        Parent.call(this);
        this.name = "tyj2";
      }
      function inherit(child, parent) {
        let prototype = Object.create(parent.prototype);
        prototype.constructor = child;
        child.prototype = prototype;
      }
      Parent.prototype.sayName = function () {
        console.log(this.name);
      };
      inherit(Child, Parent);
      //var child = new Child();
      //child.sayName();
      //console.log(child.arr);

      //19.自定义生成器且实现return，next方法
      /*
               function* generatorFunc() {
                 yield "test1";
                 yield "test2";
               }
               //使用生成器作为可迭代对象
               //使用yield实现输入与输出
               function* generatorFunc(n) {
                 let i = 0;
                 while (n--) {
                   yield i++;
                 }
               }
               //产生可迭代对象
               function* generatorFunc() {
                 yield* [1, 2, 3];
               }
               //等价于
               function* generatorFunc2(n) {
                 let i = 1;
                 while (n--) {
                   yield i;
                   i++;
                 }
               }
               function* times(n) {
                 while (n--) yield;
               }
               for (let _ of times(3)) {
                 console.log("test");
               }
               for (let _ of generatorFunc()) {
                 console.log(_);
               }
               for (let _ of generatorFunc2()) {
                 console.log(_);
               }
               let generation = generatorFunc();
               console.log(generation[Symbol.iterator]() === generation);
               console.log(generation);
               console.log(generation.next());
               // 关于yield*的值，它是关联迭代器返回{done:true}时对应的value值
               function* generatorFunc() {
                 yield* [1, 2, 3];
                 return 4;
               }
               function* generatorFunc2() {
                 console.log("iter console", yield* generatorFunc());
               }
               for (let _ of generatorFunc2()) {
                 console.log(_);
               }
               class Node {
                 constructor() {
                   this.values = [1, 2, 3, 4, 5];
                   this.key = "tyj";
                 }
                 [Symbol.iterator]() {
                   return this.values;
                 }
               }
               var node = new Node();
               for (let _ of node[Symbol.iterator]()) {
                 console.log(_);
               }
               */
      //20.代理与反射的使用
      const target = { foo: "bar" };
      const firstProxy = new Proxy(target, {
        get(target, prop, proxy) {
          console.log("firstProxy");
          return Reflect.get(target, prop, proxy);
        },
      });
      const secondProxy = new Proxy(firstProxy, {
        get(target, prop, proxy) {
          console.log("secondProxy");
          // 与捕获器拦截的对象具有相同的名称与函数签名，在这里会调用firstProxy里面的get()方法
          return Reflect.get(target, prop, proxy);
        },
      });
      /*
               console.log(secondProxy.foo);
               */
      //21.Vue2.x的实现

      //22.sleep的实现(基于Promise)，经过n秒后开始执行
      function sleep(delay) {
        return new Promise((resolve, reject) => {
          setTimeout(() => {
            resolve();
          }, delay);
        });
      }
      function sayName() {
        console.log("obj`s name is tyj");
      }
      async function func(delay) {
        await sleep(3000);
        sayName();
      }
      //func();
      //23.reduce的实现

      Array.prototype.Reduce = function (fn, base) {
        var self = this;
        const n = self.length;
        for (let i = 0; i < n; i++) {
          if (typeof base === "undefined") {
            base = fn(self[i], self[i + 1], i + 1, self);
            i++;
          } else {
            base = fn(base, self[i], i, self);
          }
        }
        return base;
      };
      /*
               let arr = [1, 2, 3, 4, 5, 6];
               console.log(
                 arr.Reduce((pre, cur, currentindex, array) => {
                   return pre + cur;
                 }, 7)
               );
               */
      //24.实现对象的属性定义，属性的读取，对象的混用
      var obj = {};
      Object.defineProperties(obj, {
        foo: {
          value: 200,
          writable: true,
          enumerable: true,
          configurable: true,
        },
        year_: {
          value: 2001,
          writable: true,
          enumerable: true,
          configurable: true,
        },
        year: {
          set(newValue) {
            this.year_ = newValue;
          },
          get() {
            return this.year_;
          },
        },
      });
      /*
               console.log(Object.getOwnPropertyDescriptors(obj));
               console.log(obj.hasOwnProperty("year_"));
               let obj2 = {};
               let obj3 = { id: [1, 2, 3, 4] };
               Object.assign(obj2, obj, obj3);
               obj2.year = 201;
               console.log(obj.year, obj2.year);
               obj2.id.push(4);
               console.log(obj2.id, obj3.id);
               function recursiveCheckEqual(x, ...rest) {
                 return (
                   Object.is(x, rest[0]) &&
                   (rest.length < 2 || recursiveCheckEqual(...rest))
                 );
               }
               console.log(recursiveCheckEqual(+0, -0));
               */

      //25.实现柯里化add函数
      function add(a, b, c, d) {
        return a + b + c + d;
      }
      function curry(fn, ...res) {
        if (fn.length === res.length) {
          // fn.length指的是fn参数的长度
          return fn(...res);
        }
        var args1 = Array.of(...res);
        return function () {
          var args2 = Array.prototype.slice.call(arguments);
          var args = args1.concat(args2);
          return fn(...args);
        };
      }
      /*
               var func = curry(add, 1, 2);
               console.log(func(3, 4));
               */

      //26. 创建对象以及实现对象的继承
      //(1)组合继承
      //(2)寄生式组合继承
      function SuperType(name) {
        this.name = name;
        this.superArray = [1, 2, 3, 4, 5];
      }
      function SubType(name) {
        SuperType.call(this, name);
        this.subArray = [1, 2, 3, 4];
      }
      SuperType.prototype.sayName = function () {
        return this.name;
      };
      SubType.prototype = new SuperType();
      SubType.prototype.constructor = SubType;
      /*
               var instance = new SubType("tyj");
               instance.superArray.push(6);
               console.log(new SuperType().superArray, instance.sayName());
               */

      //(2)寄生组合式继承，在组合继承中调用了两次SuperType构造函数，导致SubType的实例和SubType的原型上出现了相同重复的属性
      //效果与（1）相同，且减少了一次父类构造函数的调用
      function SuperType(name) {
        this.name = name;
        this.superArray = [1, 2, 3, 4, 5];
      }
      function SubType(name) {
        SuperType.call(this, name);
        this.subArray = [1, 2, 3, 4];
      }
      SuperType.prototype.sayName = function () {
        return this.name;
      };
      SuperType.prototype.array = [, 1, 23];
      function object(obj) {
        function F() {}
        F.prototype = obj;
        return new F();
      }
      function inherit(SubType, SuperType) {
        let prototype = object(SuperType.prototype); //继承父类原型
        prototype.constructor = SubType; //增强对象
        SubType.prototype = prototype; //对象赋给子类原型
      }
      inherit(SubType, SuperType);
      /*
               var instance = new SubType("tyj");
               instance.superArray.push(6);
               console.log(instance.superArray, instance.sayName());
               instance.array.push(5);
               console.log(instance.array, new SuperType().array);
               */

      //27. 通过defineProperty对于数组或对象进行深度监听；通过proxy对数组或对象进行监听
      //https://juejin.cn/post/6844903597591773198#heading-0
      const arrayMethods = [
        "push",
        "pop",
        "shift",
        "unshift",
        "splice",
        "sort",
        "reverse",
      ];
      const newExtend = Object.create(Array.prototype);
      arrayMethods.forEach((item, index) => {
        const oldMethod = Array.prototype[item];
        const newMethod = function (...args) {
          oldMethod.call(this, ...args);
          console.log(`${item} 方法被执行`);
        };
        newExtend[item] = newMethod;
      });
      /*
               var arr = [1, 2, 3];
               if (Array.isArray(arr)) arr.__proto__ = newExtend;
               console.log(arr.__proto__);
               arr.push(4);
               console.log(arr);
               */
      const createProxy = function (data) {
        if (
          data &&
          typeof data === "object" &&
          Object.prototype.toString.call(data) === "[object Object]"
        ) {
          for (let i in data) {
            if (typeof i === "object") {
              definePropertyObject(data, i, data[i]);
            } else {
              definePropertyBasic(data, i, data[i]);
            }
          }
        }
      };
      function definePropertyBasic(data, prop, value) {
        Object.defineProperty(data, prop, {
          enumerable: true,
          configurable: false,
          set(newValue) {
            if (value === newValue) return;
            console.log(`${value}--->${newValue}`);
            value = newValue;
          },
          get() {
            console.log(`${value}`);
            return value;
          },
        });
      }
      function definePropertyObject(data, prop, value) {
        createProxy(value);
        data[prop] = new Proxy(value, {
          set(value, property, val, proxy) {
            console.log(`${value}--->${val}`);
            return Reflect.set(value, property, val, proxy);
          },
          get(value, property, proxy) {
            console.log(`${value}`);
            return Reflect.get(value, property, proxy);
          },
        });
      }
      /*
               let data = {
                 name: "Jiang",
                 userInfo: {
                   gender: 0,
                   movies: [],
                 },
                 list: [],
               };
               createProxy(data);

               data.name = "Solo";
               data.userInfo.gender = 0;
               data.userInfo.movies.push("星际穿越");
               data.list.push(1);

               */
      //28.手动实现发布订阅
      class eventEmitter {
        constructor() {
          this.events = {};
        }
        on(event, callback) {
          if (!this.events[event]) {
            this.events[event] = [callback];
          } else {
            this.events[event].push(callback);
          }
        }
        emit(event) {
          this.events[event] && this.events[event].forEach((item) => item());
        }
      }
      let emitter = new eventEmitter();
      function sayName1() {
        console.log("name1");
      }
      function sayName2() {
        console.log("name2");
      }
      /*
      emitter.on("sayName", sayName1);
      emitter.on("sayName", sayName2);
      emitter.emit("sayName");
      */

      //29.手动实现观察者
      //被观察者与观察者
      //被观察者要收集观察者，只要被观察者出现状态更新会通知观察者触发update函数
      // 被观察者
      class Baby {
        constructor(state) {
          this.state = state;
          this.observers = [];
        }
        setState(state) {
          this.state = state;
          this.observers.forEach((item) => item.update(this));
        }
        collectObserver(observer) {
          this.observers.push(observer);
        }
      }
      // 观察者
      class Observer {
        constructor(name) {
          this.name = name;
        }
        update(baby) {
          console.log(`baby的state变为了${baby.state}`);
        }
      }
      /*
               let mother = new Observer("妈妈");
               let father = new Observer("爸爸");
               let baby = new Baby("饿了");
               baby.collectObserver(mother);
               baby.collectObserver(father);
               baby.setState("不饿了");
               */
      //30.Object.freeze
      //Object.preventExtensions(obj);等价于obj = Object.preventExtensions({});
      //Object.seal(obj);
      //Object.freeze(obj);

      Object.prototype.Freeze = function (obj) {
        if (typeof obj === "object") {
          Object.seal(obj);
          for (let prop in obj) {
            if (obj.hasOwnProperty(prop)) {
              Object.defineProperties(obj, prop, {
                writable: false,
              });
              Freeze(obj[prop]);
            }
          }
        }
      };
      var isMatch = function (s, p) {
        const m = s.length;
        const n = p.length;
        let dp = new Array(m + 1);
        for (let i = 0; i <= m; i++) {
          dp[i] = new Array(n + 1).fill(0);
        }
        dp[0][0] = 1;
        var match = function (i, j) {
          if (i === 0) return 0;
          if (p[j - 1] === ".") return 1;
          return s[i - 1] === p[j - 1];
        };
        for (let i = 0; i <= m; i++) {
          for (let j = 1; j <= n; j++) {
            if (p[j - 1] !== "." && p[j - 1] !== "*") {
            } else if (p[j - 1] === ".") {
            } else {
            }
          }
        }
      };
      //31.Promise.all
      Promise.prototype.All = function (args) {
        const n = args.length;
        let c = 0; //记录resolved的次数
        let result = []; //记录resolved的解决值
        return new Promise((resolve, reject) => {
          for (let i = 0; i < args.length; i++) {
            Promise.resolve(args[i]).then(
              (res) => {
                c++;
                result[i] = res;
                if (c === n) {
                  resolve(result);
                }
              },
              (err) => {
                reject(err);
              }
            );
          }
        });
      };
      Promise.prototype
        .All([
          1,
          new Promise((resolve, reject) => {
            setTimeout(resolve, 1000);
          }),
          new Promise((resolve, reject) => {
            setTimeout(resolve, 2000);
          }),
        ])
        .then(console.log)
        .catch(console.log);
      //32.Promise.allSettled
      //33.Promise.finally
      //34.规约与异步函数
      //(1）demo，封装函数实现异步延迟输出
      /*
      var p1 = new Promise((resolve, reject) => {
        console.log("p1");
        setTimeout(resolve, 1000);
      });
      p1.then(
        () =>
          new Promise((resolve, reject) => {
            console.log("p2");
            setTimeout(resolve, 1000);
          })
      ).then(
        () =>
          new Promise((resolve, reject) => {
            console.log("p3");
            setTimeout(resolve, 1000);
          })
      );
      function delayResolved(str, delay) {
        return new Promise((resolve, reject) => {
          console.log(str);
          setTimeout(() => {
            resolve();
          }, delay);
        });
      }
      delayResolved("p1", 1000)
        .then(() => delayResolved("p2", 1000))
        .then(() => delayResolved("p3", 1000));

        */
      //（2）使用期约串行合成实现高阶函数
      /*
      function addTwo(x) {
        return x + 2;
      }
      function addFive(x) {
        return x + 5;
      }
      function addTen(x) {
        return x + 10;
      }
      console.log(addTwo(addFive(addTen(0)))); //高阶函数合成
      function add(x) {
        return Promise.resolve(x).then(addTwo).then(addFive).then(addTen);
      }
      add(0).then(console.log); //期约串行合成
      function add(x) {
        return [addTwo, addFive, addTen].reduce((promise, fn) => {
          return promise.then(fn);
        }, Promise.resolve(x));
      } // 使用reduce进行期约串行合成
      add(0).then(console.log);
      // 创建通用方法实现期约串行合成
      function compose(...args) {
        return function (x) {
          return args.reduce((promise, fn) => {
            return promise.then(fn);
          }, Promise.resolve(x));
        };
      }
      var add = compose(addTwo, addFive, addTen);
      add(0).then(console.log);
      */

      //(3)异步函数策略
      //(3.1)实现sleep()
      function sleep(delay) {
        return new Promise((resolve, reject) => {
          setTimeout(resolve, delay);
        });
      }
      /*
      async function print() {
        const before = Date.now();
        await sleep(1000);
        const now = Date.now();
        console.log(`${now - before}ms`);
      }
      */
      print();
      //(3.2)利用平行执行
      //(3.3)串行执行期约
      //(3.4)栈期约与内存管理

      // 35.函数递归时为了避免原函数失效，使用arguments.callee和命名函数表达式去引用当前函数
      // arguments.callee去引用原函数会报错
      // 命名函数表达式

      var factorial = function f(num) {
        if (num <= 1) return 1;
        else {
          return num * f(num - 1);
        }
      };
      function factorial(num) {
        if (num <= 1) return 1;
        else {
          return num * arguments.callee(num - 1);
        }
      }
      let f = factorial;
      factorial = null;

      //console.log(f(5));

      // 36.函数调用的this对象
      // 内部函数无法直接访问外部函数的this对象与arguments对象，必须要使用引用保存在闭包可以访问的一个对象
      window.identity = "The Window";
      var object = {
        identity: "My object",
        getIndentity() {
          return function () {
            return this.identity;
          };
        },
      };
      //console.log(object.getIndentity())
      var object = {
        identity: "My object",
        getIndentity() {
          let that = this;
          return function () {
            return that.identity;
          };
        },
      };
      var object = {
        identity: "My object",
        getIndentity() {
          return this.identity;
        },
      };
      /*
      console.log(object.getIndentity())
      console.log((object.getIndentity)());
      console.log((object.getIndentity=object.getIndentity)())*/
      //37.使用立即调用的函数表达式模拟一个块作用域
      let divs = document.querySelectorAll("div");
      for (var i = 0; i < divs.length; i++) {
        divs[i].addEventListener(
          "click",
          (function (frozenCounter) {
            return function () {
              console.log(frozenCounter);
            };
          })(i)
        );
      }
      // 通过IIFE，传入每次循环时的索引，锁定点击时显示的索引值，也就是frozenCounter
      for (let i = 0; i < divs.length; i++) {
        divs[i].addEventListener("click", function () {
          console.log(i);
        });
      }

      //38.apply和defineProperty的区别
      var obj = new Map();
      obj.set("name", "tyj");
      function reactive(obj) {
        if (typeof obj !== " object" && obj != null) return obj;
        let proxy = new Proxy(obj, {
          set(obj, prop, value, proxy) {
            const oldValue = obj[prop];
            const newValue = value;
            console.log(`${oldValue}-->${newValue}`);
            return Reflect.set(obj, prop, value, proxy);
          },
          get(obj, prop, proxy) {
            const value = obj[prop];
            console.log(`${value}`);
            return Reflect.get(obj, prop, proxy);
          },
          deleteProperty(obj, prop, proxy) {
            console.log(`${prop} deleted`);
            return Reflect.deleteProperty(obj, prop, proxy);
          },
        });
        return proxy;
      }

      // 39.浏览器中的查询参数的获取。
      // ①location.search
      // ②使用new URLSearchParams(location search)
      var qs2 = "q=javascript&num=10";
      var getQueryStringArgs = function (qs2) {
        let qs =
          location.search.length !== 0 ? location.search.substring(1) : qs2;
        let args = {};
        for (let item of qs.split("&").map((qsItem) => {
          return qsItem.split("=");
        })) {
          args[item[0]] = item[1];
        }
        return args;
      };
      var getQueryStringArgs2 = function (qs2) {
        let searchParams = new URLSearchParams(qs2);
        let args = {};
        for (let item of searchParams) {
          args[item[0]] = item[1];
        }
        return args;
      };
      /*
        console.log(getQueryStringArgs(qs2));
        console.log(getQueryStringArgs2(qs2));
        */

      //40.MutationObserver接口的回调函数
      var observer = new MutationObserver((MutationRecords) => {
        for (let mutationRecord of MutationRecords) {
          console.log(mutationRecord);
        }
      });
      observer.observe(document.body, { attributes: true });
      /*
        document.body.setAttribute("foo", "bar");
        setTimeout(() => {
          observer.disconnect();
          document.body.setAttribute("bar", "baz");
        }, 1000);
        setTimeout(() => {
          observer.observe(document.body, { attributes: true });
          document.body.setAttribute("baz", "qux");
        });
        */

      //console.log(document.documentElement,document.childNodes[0],document.children[0],document.firstChild)
      // 异步执行回调，因此如果想要获取每一次MutationRecord的话，需要添加回调

      //41.利用documentFragment减少document的渲染次数
      let documentFragment = document.createDocumentFragment();
      let ul = document.getElementsByClassName("myList").item(0);
      for (let i = 0; i < 3; i++) {
        let li = document.createElement("li");
        li.appendChild(document.createTextNode(`item ${i}`));
        documentFragment.appendChild(li);
      }
      //ul.appendChild(documentFragment);

      // 42.利用ajax
      //ajax请求网络数据示例
      var xhr = null;
      // 兼容性处理
      if (window.XMLHttpRequest) {
        xhr = new XMLHttpRequest();
      } else {
        xhr = new ActiveXObject("Microsoft.XMLHTTP");
      }
      xhr.open("GET", "www.baidu.com", true);
      //xhr.setRequestHeader("Content-type", "application/x-www-form-urlencoded");
      xhr.onreadystatechange = function () {
        if (xhr.status === 200 && xhr.readystate === 4) {
          document.querySelector("p").innerHTML = xhr.responseText;
        }
        //console.log(xhr.responseText);
      };
      xhr.send();
      //使用fetch改写
      //fetch请求本地text数据
      //fetch请求本地JSON数据

      function getText() {
        const btn = document.querySelector("#btn");
        fetch("xxx.txt")
          .then((res) => res.text())
          .then((res) => {
            console.log(res);
            btn.innerHTML = res;
          })
          .catch((err) => {
            console.log(err);
          });
      }
      function getjson() {
        const btn = document.querySelector("#btn");
        fetch("xxx.txt")
          .then((res) => res.json())
          .then((data) => {
            console.log(data);
            let output = "";
            //json数据以对象数组的形式呈现，因此需要进行迭代
            data.forEach((res) => {
              output += `<li>${res.title}<li>`;
            });
            res.innerHTML = output;
          })
          .catch((err) => {
            console.log(err);
          });
      }
      // 43.使用Generator为原生Object对象添加iterator接口
      function* iterator(obj) {
        let props = Reflect.ownKeys(obj);
        for (let prop of props) {
          yield [prop, obj[prop]];
        }
      }
      var obj = { name: "tyj", age: 20 };
      /*
      for (let [key, value] of iterator(obj)) {
        console.log(key, value);
      }
      */
      // 44.Promise
      Promise.prototype.myresolve = function (val) {
        if (val instanceof Promise) {
          return val;
        } else {
          return new Promise((resolve, reject) => resolve(val));
        }
      };
      Promise.prototype.myreject = function (reason) {
        return new Promise((resolve, reject) => reject(reason));
      };
      Promise.prototype.myall = function (promiseArr) {
        let idx = 0;
        let res = [];
        return new Promise((resolve, reject) => {
          promiseArr.forEach((item) => {
            Promise.resolve(item).then(
              (val) => {
                res[idx] = val;
                idx++;
                if (idx === promiseArr.length) resolve(res);
              },
              (err) => {
                reject(err);
              }
            );
          });
        });
      };
      Promise.all = function (promiseArr) {
        let index = 0,
          result = [];
        return new Promise((resolve, reject) => {
          promiseArr.forEach((p, i) => {
            Promise.resolve(p).then(
              (val) => {
                index++;
                result[i] = val;
                if (index === promiseArr.length) {
                  resolve(result);
                }
              },
              (err) => {
                reject(err);
              }
            );
          });
        });
      };
      Promise.prototype.myrace = function (promiseArr) {
        return new Promise((resolve, reject) => {
          for (let i = 0; i < promiseArr.length; i++) {
            Promise.resolve(promiseArr[i]).then(
              (val) => {
                resolve({ i, val });
              },
              (err) => {
                reject({ i, err });
              }
            );
          }
        });
      };
      Promise.race = function (promiseArr) {
        return new Promise((resolve, reject) => {
          promiseArr.forEach((p) => {
            Promise.resolve(p).then(
              (val) => {
                resolve(val);
              },
              (err) => {
                rejecte(err);
              }
            );
          });
        });
      };
      Promise.prototype.myany = function (promiseArr) {
        let idx = 0;
        return new Promise((resolve, reject) => {
          promiseArr.forEach((item, i) => {
            Promise.resolve(item).then(
              (val) => {
                resolve(val);
              },
              (err) => {
                idx++;
                if (idx === promiseArr.length) {
                  reject(new AggregateError("All promises rejected"));
                }
              }
            );
          });
        });
      };
      Promise.any = function (promiseArr) {
        let index = 0;
        return new Promise((resolve, reject) => {
          if (promiseArr.length === 0) return;
          promiseArr.forEach((p, i) => {
            Promise.resolve(p).then(
              (val) => {
                resolve(val);
              },
              (err) => {
                index++;
                if (index === promiseArr.length) {
                  // 一个AggregateError当需要由操作报告多个错误被抛出
                  reject(new AggregateError("All promises were rejected"));
                }
              }
            );
          });
        });
      };
      // 45. 兼容性处理添加动态脚本
      function loadScriptString(str) {
        const script = document.createElement("script");
        script.type = "text/javascript";
        try {
          script.appendChild(document.createTextNode(code));
        } catch (e) {
          script.text = code;
        }
        document.appendChild(script);
      }

      // 46.动态添加样式
      // （1）link标签
      function loadLink(url) {
        const link = document.createElement("link");
        link.ref = "stylesheet";
        link.type = "text/css";
        link.href = url;
        const head = document.getElementsByTagName("head")[0];
        head.appendChild(link);
      }
      // （2）style标签,解决IE的兼容性问题，在IE使用styleSheet需要小心容易造成浏览器崩溃
      function loadStyle(styleText) {
        const style = document.createElement("style");
        try {
          style.appendChild(document.createTextNode(styleText));
        } catch (e) {
          style.styleSheet.cssText = styleText;
        }
        const head = document.getElementsByTagName("head")[0];
        head.appendChild(style);
      }

      //47. 求斐波那契数列函数的尾调用优化
      function fib(n) {
        if (n < 2) return n;
        return fib(n - 1) + fib(n - 2);
        // 栈桢数的内存复杂度是O(2^n),会爆栈
      }
      function fib(n) {
        return fibFunc(0, 1, n);
      }
      function fibFunc(a, b, n) {
        if (n === 0) return a;
        return fibFunc(b, a + b, n - 1);
        // 栈帧数的内存复杂度是O(1)
      }

      Function.prototype._bind = function () {
        if(typeof this !== 'function')throw Error("must be function")
        var context = [...arguments].shift();
        context = context | window;
        var args = Array.prototype.slice([...arguments]);
        const key = Symbol();
        context[key] = this;
        const res = context[key](args);
        delete context[key];
        console.log(res);
        return res;
      };
      
      function equal() {
        const o1 = {
          name: "z",
          fn: function () {
            return this.name;
          },
        };
        const o2 = { name: "g" };
        const result = o1.fn._bind(o2);
        return result() === "g";
      }
      // equal()
    </script>
  </body>
</html>

```