### 垃圾回收策略

`Javascript`的内存管理有一个概念：可达性，就是以某种方式可访问或者可用的值，它们被保证存储在内存中，若不可访问则需要回收。

垃圾回收机制就是定义找出哪些不再用到的内存（变量），释放掉其内存，避免内存占用越来越高以及影响系统性能。

两种算法用于垃圾回收：

- 标记清除算法
- 引用计数算法



#### 标记清除算法

目前为止大多数浏览器的`Javascript`引擎都采用标记清除算法。不同浏览器对该算法进行不同的优化，同时运行垃圾回收的频率有所差异。

此算法分为 `标记` 和 `清除` 两个阶段，标记阶段即为所有活动对象做上标记，清除阶段则把没有标记（也就是非活动对象）销毁。

给变量标记的方法很多，比如说当变量进入执行环境时，反转标记位（二进制表示标记），也可以维护进入环境的变量与离开环境的变量两个列表等。标记方法不是重要的，重要的是其策略。

整个标记清除算法大致过程就像下面这样

- 垃圾收集器在运行时，从出发点（全局window对象或DOM树）中遍历变量内存中的所有对象，给他们都加上一个标记，假设内存中所有对象都是垃圾，全标记为0
- 然后从各个根对象开始遍历，把不是垃圾的节点改成1
- 清理所有标记为0的垃圾，销毁并回收它们所占用的内存空间
- 最后，把所有内存中对象标记修改为0，等待下一轮垃圾回收

**优点**

标记清除算法的优点只有一个，那就是实现比较简单，打标记也无非打与不打两种情况，这使得一位二进制位（0和1）就可以为其标记，非常简单

**缺点**

标记清除算法有一个很大的缺点，就是在清除之后，剩余的对象内存位置是不变的，也会导致空闲内存空间是不连续的，出现了 `内存碎片`（如下图），并且由于剩余空闲内存不是一整块，它是由不同大小内存组成的内存列表，这就牵扯出了内存分配的问题

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/12247ac3d8f249a5ab85b9b40ba1147b~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp)

假设我们新建对象分配内存时需要大小为 `size`，由于空闲内存是间断的、不连续的，则需要对空闲内存列表进行一次单向遍历找出大于等于 `size` 的块才能为其分配（如下图）

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fb5107f04a3249ce8d37ec7cc5fd9668~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp)

那如何找到合适的块呢？我们可以采取下面三种分配策略

- `First-fit`，找到大于等于 `size` 的块立即返回
- `Best-fit`，遍历整个空闲列表，返回大于等于 `size` 的最小分块
- `Worst-fit`，遍历整个空闲列表，找到最大的分块，然后切成两部分，一部分 `size` 大小，并将该部分返回

这三种策略里面 `Worst-fit` 的空间利用率看起来是最合理，但实际上切分之后会造成更多的小块，形成内存碎片，所以不推荐使用，对于 `First-fit` 和 `Best-fit` 来说，考虑到分配的速度和效率 `First-fit` 是更为明智的选择

综上所述，标记清除算法或者说策略就有两个很明显的缺点

- **内存碎片化**，空闲内存块是不连续的，容易出现很多空闲内存块，还可能会出现分配所需内存过大的对象时找不到合适的块
- **分配速度慢**，因为即便是使用 `First-fit` 策略，其操作仍是一个 `O(n)` 的操作，最坏情况是每次都要遍历到最后，同时因为碎片化，大对象的分配效率会更慢

PS：标记清除算法的缺点的本质是清除对象导致空余内存不连续。

使用**标记整理算法**，把不需要清理的对象向内存的一端移动，最后清理边界的内存。

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c04b0a5a40084e0ba4550500c57f2270~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp)





#### 引用计数算法

更早使用的垃圾回收算法，当对象没有其他对象引用到它就会被清除。它的策略就是跟踪记录每个变量值被使用的次数。



```
function test(){
  let A = new Object()
  let B = new Object()

  A.b = B
  B.a = A
}
```

观察上面的函数，引用计数算法在处理循环引用上束手无策，因为对象A和B通过各自的属性相互引用。

而且从标记清除算法的角度说，当函数结束后，对象A，B被应该被标记清除。在引用计数算法中，由于引用次数不为0，对象A，B内存不会被释放，造成大量内存被无效占用。

**优点**

引用计数算法的优点我们对比标记清除来看就会清晰很多，首先引用计数在引用值为 0 时，也就是在变成垃圾的那一刻就会被回收，所以它可以立即回收垃圾

而标记清除算法需要每隔一段时间进行一次，那在应用程序（JS脚本）运行过程中线程就必须要暂停去执行一段时间的 `GC`，另外，标记清除算法需要遍历堆里的活动以及非活动对象来清除，而引用计数则只需要在引用时计数就可以了

**缺点**

引用计数的缺点想必大家也都很明朗了，首先它需要一个计数器，而此计数器需要占很大的位置，因为我们也不知道被引用数量的上限，还有就是无法解决循环引用无法回收的问题，这也是最严重的





### V8对GC的优化

[「硬核JS」你真的了解垃圾回收机制吗 - 掘金 (juejin.cn)](https://juejin.cn/post/6981588276356317214#heading-6)